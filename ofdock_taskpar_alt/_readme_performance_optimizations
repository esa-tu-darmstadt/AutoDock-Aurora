----------------------------------------------------------------------
----------------------------------------------------------------------
Krnl_GG, auxiliary_genetic
In binary_tournament_selection, rand_level(tournament rate) was 
multiplied by 100 unnecesarily in 4 times.

MODIFICATION
tournament_rate is multiplied by 100 in the host, and then passed
to Krnl_GG


----------------------------------------------------------------------
----------------------------------------------------------------------
Declare global args as __global const where appropriate 

MODIFICATION

Krnl_GA: GlobPopulationNext, GlobEnergyNext
Krnl_IC: GlobPopulationCurrent
Krnl_GG: GlobPopulationCurrent, GlobEnergyCurrent

----------------------------------------------------------------------
----------------------------------------------------------------------

Remove complex parent selection in binary tournament

Originally, while loops were used to make sure both parents are different.
But we didnt care about this in the ofdock_amd.

MODIFICATION

Corresponding while loops were removed and not-guarded calls to rand() 
were placed.

----------------------------------------------------------------------
----------------------------------------------------------------------

First improvement of Krnl_LS

Recode loop so redundand calls are avoided:

if (positive_direction == true) {
entity_possible_new_genotype [3] = map_angle(entity_possible_new_genotype [3], 360.0f);

else {
entity_possible_new_genotype [3] = map_angle(entity_possible_new_genotype [3], 360.0f);

}


MODIFICATION

if (positive_direction == true) {

else {
}

entity_possible_new_genotype [3] = map_angle(entity_possible_new_genotype [3], 360.0f);


Taking into account all previous steps, hw utilization was reduced down to:

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   59%                     ;
; ALUTs                                  ;   26%                     ;
; Dedicated logic registers              ;   34%                     ;
; Memory blocks                          ;   74%                     ;
; DSP blocks                             ;   26%                     ;
+----------------------------------------+---------------------------;


----------------------------------------------------------------------
----------------------------------------------------------------------
Reduced number of bits for counter in Krnl_LS
This counter is used for indexing entities subjected to LS
which represent typically 6% of the population

for (uint ls_ent_cnt=0; ls_ent_cnt<DockConst->num_of_lsentities; ls_ent_cnt++) {

Krnl_LS
ALUTs		FFs		RAMs		DSPs
21896 (3%)	56096 (4%)	163 (7%)	63 (4%


MODIFICATION

for (ushort ls_ent_cnt=0; ls_ent_cnt<DockConst->num_of_lsentities; ls_ent_cnt++) {

Krnl_LS
ALUTs		FFs		RAMs		DSPs
21885 (3%)	56025 (4%)	163 (7%)	63 (4%)

----------------------------------------------------------------------
----------------------------------------------------------------------

Second improvement of Krnl_LS

In one of the previous modifications, we came out with 
this modification:


if (positive_direction == true) {

else {
}

entity_possible_new_genotype [3] = map_angle(entity_possible_new_genotype [3], 360.0f);

The code inside either the if or else branches contain statements
that can be grouped into one single for loop.

Krnl_LS
ALUTs		FFs		RAMs		DSPs
21885 (3%)	56025 (4%)	163 (7%)	63 (4%)

MODIFICATION
Grouping all them helps reducing area as well

Krnl_LS
ALUTs		FFs		RAMs		DSPs
20652 (3%)	53356 (3%)	143 (6%)	43 (3%)

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   59%                     ;
; ALUTs                                  ;   26%                     ;
; Dedicated logic registers              ;   34%                     ;
; Memory blocks                          ;   73%                     ;
; DSP blocks                             ;   24%                     ;
+----------------------------------------+---------------------------;

----------------------------------------------------------------------
----------------------------------------------------------------------

The same type of modification as in the previous item.
This time the for loop is related to genotyoe_deviation[]:

genotype_deviate [0] = rho*DockConst->base_dmov_mul_sqrt3*(2*myrand(&prng)-1);
genotype_deviate [1] = rho*DockConst->base_dmov_mul_sqrt3*(2*myrand(&prng)-1);
genotype_deviate [2] = rho*DockConst->base_dmov_mul_sqrt3*(2*myrand(&prng)-1);

for (uchar i=3; i<DockConst->num_of_genes; i++) {
	genotype_deviate [i] = rho*DockConst->base_dang_mul_sqrt3*(2*myrand(&prng)-1);
}


MODIFICATION:

for (uchar i=0; i<DockConst->num_of_genes; i++) {
	genotype_deviate [i] = rho*DockConst->base_dang_mul_sqrt3*(2*myrand(&prng)-1);
}

It also helps reducing area:

Krnl_LS
ALUTs		FFs		RAMs		DSPs
18790 (2%)	50257 (3%)	143 (6%)	25 (2%)

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   58%                     ;
; ALUTs                                  ;   26%                     ;
; Dedicated logic registers              ;   33%                     ;
; Memory blocks                          ;   73%                     ;
; DSP blocks                             ;   23%                     ;
+----------------------------------------+---------------------------;


----------------------------------------------------------------------
----------------------------------------------------------------------



Again in Krnl_LS, calculation can be grouped inside a single for loop:

entity_possible_new_genotype [3] = map_angle_360(entity_possible_new_genotype [3]);
entity_possible_new_genotype [4] = map_angle_180(entity_possible_new_genotype [4]);

for (uchar i=5; i<DockConst->num_of_genes; i++) {
	entity_possible_new_genotype [i] = map_angle_360(entity_possible_new_genotype [i]);
}

MODIFICATION:

for (uchar i=3; i<DockConst->num_of_genes; i++) {
	if (i == 4) {
		entity_possible_new_genotype [i] = map_angle_180(entity_possible_new_genotype [i]);
	} else {
		entity_possible_new_genotype [i] = map_angle_360(entity_possible_new_genotype [i]);
	}
}


Krnl_LS
ALUTs		FFs		RAMs		DSPs
15854 (2%)	43513 (3%)	135 (6%)	23 (2%)

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   58%                     ;
; ALUTs                                  ;   25%                     ;
; Dedicated logic registers              ;   33%                     ;
; Memory blocks                          ;   73%                     ;
; DSP blocks                             ;   23%                     ;
+----------------------------------------+---------------------------;
	
THIS PROVIDES UTILIZATION SAVINGS, INDEED. BUT IT CAUSES THE LOOP TO NOT 
BE PIPELINED AS IT PRESENTS A DIVERGENT INNER LOOP. WE SWITCHED IT BACK
TO THE PREVIOUS VERSION.

Krnl_LS
ALUTs		FFs		RAMs		DSPs
18790 (2%)	50257 (3%)	143 (6%)	25 (2%)

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   58%                     ;
; ALUTs                                  ;   26%                     ;
; Dedicated logic registers              ;   33%                     ;
; Memory blocks                          ;   73%                     ;
; DSP blocks                             ;   23%                     ;
+----------------------------------------+---------------------------;





----------------------------------------------------------------------
----------------------------------------------------------------------

Position data is transferred between kernels using three 
separate channels: x, y, z, but this implies having fences between them.
This could be unnecessary as the x,y,z data is used together.

					ALUTs	FFs	RAMs	DSPs
Krnl_GA.cl:44 (chan_Conf2Intere_x)	49	223	1	0
Krnl_GA.cl:45 (chan_Conf2Intere_y)	49	223	1	0
Krnl_GA.cl:46 (chan_Conf2Intere_z)	49	223	1	0

Krnl_GA.cl:51 (chan_Conf2Intrae_x)	49	223	1	0	
Krnl_GA.cl:52 (chan_Conf2Intrae_y)	49	223	1	0	
Krnl_GA.cl:53 (chan_Conf2Intrae_z)	49	223	1	0

MODIFICATION

Krnl_GA.cl:47 (chan_Conf2Intere_xyz)	52	498	3	0
Krnl_GA.cl:56 (chan_Conf2Intrae_xyz)	52	498	3	0

Overall utilization % is the same
But we can see we won in ALUs.

----------------------------------------------------------------------
----------------------------------------------------------------------
In Krnl_Conform
Using a vector to replace loc_coords_x, loc_coords_y, loc_coords_z requires more logic
even though, the overall hw utilization is the same.
This idea is discarded.

----------------------------------------------------------------------
----------------------------------------------------------------------

Deviation dmov and dang were incorrectly assigned in both Krnl_GG and Krnl_LS, 
and have been being used that way all this time!!!

We tried removing map_angle(), getting (possibly faster execution) and less area
consumption. However it shouldn't be removed as spherical coordinates used in 
the genotypes, require a restriction on angles (see wikipedia) in order the define 
a unique set of spherical coordinates for a point. SO WE PUt THEM BACK!

MODIFICATION:
Now bigger cluster is at least 20% in size compared to whole number of runs.
Still some big energy values are computed by both cpu and device (check final_population_runXX.txt)


Overall utilization results:

+--------------------------------------------------------------------+
; Estimated Resource Usage Summary                                   ;
+----------------------------------------+---------------------------+
; Resource                               + Usage                     ;
+----------------------------------------+---------------------------+
; Logic utilization                      ;   59%                     ;
; ALUTs                                  ;   26%                     ;
; Dedicated logic registers              ;   34%                     ;
; Memory blocks                          ;   73%                     ;
; DSP blocks                             ;   24%                     ;
+----------------------------------------+---------------------------;

----------------------------------------------------------------------
----------------------------------------------------------------------

After correcting LS, so it correctly assigns pops and energies
(there was a mistake between current and next
After simplifyng crossover and mutation associated generation 
(removing mul-by-100 from Krnl, and moving it to performdocking.cpp)

The area results are same as before:
				ALUTs		FFs		RAMs		DSPs
Kernel System (Logic: 59%)	203101 (26%)	528781 (34%)	1739 (73%)	354 (23%)	

----------------------------------------------------------------------
----------------------------------------------------------------------

Here we aim to reduce the area utiized for storing "State"
pag 43 Best practices, and pag 90 for explanation

Krnl_IC:

__local float genotype [ACTUAL_GENOTYPE_LENGTH];
...
for (ushort pop_cnt = 0; ...) {
	for (uchar pipe_cnt=0; ...) {
		genotype = ...
	}
}


Krnl_IC.cl:14 (genotype):
Local memory: Good but replicated.
Requested size 256 bytes (rounded up to nearest power of 2), implemented size 768 bytes, replicated 3 times total, stall-free, 1 read and 1 write. Additional information:
- Replicated 3 times to create private copies for simultaneous execution of 3 threads in the loop containing accesses to the array.

Usage:
		ALUTs		FFs		RAMs	DSPs
 Krnl_IC	2360 (0%)	7347 (0%)	26 (1%)	0 (0%)







MODIFICATION:
Decrease the scope of local variables

Note that is implement explicity as __local, but in the end, it is 
mapped to RAM as this array is big.

...
for (ushort pop_cnt = 0; ...) {
	float genotype [ACTUAL_GENOTYPE_LENGTH];
	
	for (uchar pipe_cnt=0; ...) {
		genotype = ...
	}
}


Krnl_IC.cl:20 (genotype):
Private memory implemented in on-chip block RAM.
Private memory: Good but replicated.
Requested size 256 bytes (rounded up to nearest power of 2), implemented size 768 bytes, replicated 3 times total, stall-free, 1 read and 1 write. Additional information:
- Replicated 3 times to create private copies for simultaneous execution of 3 threads in the loop containing accesses to the array.

Usage:
		ALUTs		FFs		RAMs	DSPs
 Krnl_IC	2360 (0%)	7347 (0%)	26 (1%)	0 (0%)


CONCLUSION: NO ADVANTAGE OF DOING THIS!!!!

----------------------------------------------------------------------
----------------------------------------------------------------------

In Krnl_InterE

WE switch back to use __local and remove the attribute that forces
implementation of x,y,z variables as private memory. WE got a big save in resources:

float __attribute__((register)) loc_coords_x[MAX_NUM_OF_ATOMS];
float __attribute__((register)) loc_coords_y[MAX_NUM_OF_ATOMS];
float __attribute__((register)) loc_coords_z[MAX_NUM_OF_ATOMS];


Kernel System (Logic: 59%)	203101 (26%)	528781 (34%)	1739 (73%)	354 (23%)	
		 Krnl_InterE	41759 (5%)	150983 (10%)	454 (19%)	58 (4%)

Krnl_IntraE.cl:22 (loc_coords_x):
Local memory: Good but replicated.
Requested size 512 bytes (rounded up to nearest power of 2), implemented size 1024 bytes, replicated 2 times total, stall-free, 2 reads and 1 write. Additional information:
- Replicated 2 times to efficiently support multiple accesses. To reduce this replication factor, reduce number of read and write accesses

MODIFICATION:

__local float loc_coords_x[MAX_NUM_OF_ATOMS];
__local float loc_coords_y[MAX_NUM_OF_ATOMS];
__local float loc_coords_z[MAX_NUM_OF_ATOMS];


Kernel System (Logic: 53%)	189611 (24%)	463520 (29%)	1691 (71%)	354 (23%)	
		Krnl_InterE	28269 (4%)	85722 (5%)	406 (17%)	58 (4%)

Krnl_InterE.cl:20 (loc_coords_x):
Local memory: Optimal.
Requested size 512 bytes (rounded up to nearest power of 2), implemented size 512 bytes, stall-free, 1 read and 1 write. Additional information:
- No additional details.

Note that according to the tool, this local memory is optimal,
and the previous one is good!

----------------------------------------------------------------------
----------------------------------------------------------------------

(1) Remove conditional write to channels within Krnl_GG
    Krnl_GG communicates to Krnl_Conform, but writing to channels is conditional
    because the it must not send always data, i.e.
    initially it must stop when active is equal to 0.
    This could (likely) impose a serialization within Krnl_GG, so removing it is 
    tested.
    Removing it, requires fixing the subsequent kernels in the processing chain:
    Conform, Inter, Intra, and Store. Basically these four kernels:
    - read the value of active (as originally)
    - instead of directly sending it, evaluate it first, so it can be switched from
      0 to 1, i.e. the kernel could be maintained active, so the remaining data
      still present in the channels can be processed.

    Krnl_Store had a Fmax issue due to a critical path formed by the integer
    comparisons. In order to reduce the comparison number, unnecessary channels are
    removed.


(2) Eliminate redundant channels betwwen Krnl_InterE and Krnl_Store
    Krnl_InterE and Krnl_IntraE, both communicate data to Krnl_Store.
    The only difference betwwen them is the date they send. Initially both 
    send also active, mode, and cnt values (through channels), but the 
    corresponding channels send the same data always (unless a serious error).
    Considering the info from Evopro paper, in which Krnl_InterE is said to be 
    the most expensive in exec time, we rremove the channels communicating 
    Knrl_InterE and Krnl_Store (this helps further reducing area utilization)
    


----------------------------
Krnl_Store

while(active) {
	case 2: // GG
		GlobEnergyNext[cnt] = InterE + IntraE;

		if ((cnt == (DockConst->pop_size)-1) || (active == 0)) {	
			write_channel_altera(chan_Store2GG_ack, 1);
		}

}
----------------------------
				ALUTs		FFs		RAMs		DSPs
Kernel System (Logic: 53%)	189664 (24%)	463726 (29%)	1687 (71%)	354 (23%)	
 		Krnl_Conform	17059 (2%)	42647 (3%)	157 (7%)	94 (6%)	
		Krnl_GA		3837 (0%)	11300 (1%)	83 (3%)		0 (0%)	
		Krnl_GG		32485 (4%)	70431 (4%)	225 (9%)	98 (6%)	
 		Krnl_IC		2360 (0%)	7347 (0%)	26 (1%)		0 (0%)	
	 	Krnl_InterE	28556 (4%)	86280 (5%)	406 (17%)	58 (4%)	
		Krnl_IntraE	16887 (2%)	54486 (3%)	289 (12%)	60 (4%)	
		Krnl_LS		20652 (3%)	53356 (3%)	143 (6%)	43 (3%)	
 		Krnl_Store	881 (0%)	3317 (0%)	16 (1%)		1 (0%)




MODIFICATIONS:

Krnl_Conform, Krnl_InterE and Krnl_IntraE (added)

} // End of LOOP_INTERE_1:	

if ((active == 0) && (cnt == (DockConst->pop_size -1))) {
	active = 0;	
}
else {
	active = 1;
}

----------------------------
Krnl_Store

while(active) {
	case 2: // GG
		GlobEnergyNext[cnt] = InterE + IntraE;


		if (cnt == DockConst->pop_size-1) {	
			write_channel_altera(chan_Store2GG_ack, 1);
		}

		if ((active == 0) && (cnt == (DockConst->pop_size -1))) {
			active = 0;	
		}
		else {
			active = 1;
		}
}
----------------------------

				ALUTs		FFs		RAMs		DSPs
Kernel System (Logic: 52%)	189222 (24%)	462250 (29%)	1685 (71%)	354 (23%)	
		Krnl_Conform	17059 (2%)	42647 (3%)	157 (7%)	94 (6%)	
 		Krnl_GA		3837 (0%)	11300 (1%)	83 (3%)		0 (0%)	
 		Krnl_GG		32485 (4%)	70431 (4%)	225 (9%)	98 (6%)	
 		Krnl_IC		2360 (0%)	7347 (0%)	26 (1%)		0 (0%)	
 		Krnl_InterE	28234 (4%)	85021 (5%)	404 (17%)	58 (4%)	
 		Krnl_IntraE	16887 (2%)	54486 (3%)	289 (12%)	60 (4%)	
 		Krnl_LS		20652 (3%)	53356 (3%)	143 (6%)	43 (3%)	
		Krnl_Store	793 (0%)	3132 (0%)	16 (1%)		1 (0%)
